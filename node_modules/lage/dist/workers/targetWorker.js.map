{"version":3,"file":"targetWorker.js","sources":["../../../worker-threads-pool/lib/stdioStreamMarkers.js","../../../worker-threads-pool/lib/registerWorker.js","../../../worker-threads-pool/lib/createFilteredStreamTransform.js","../../../worker-threads-pool/lib/TaskInfo.js","../../../worker-threads-pool/lib/ThreadWorker.js","../../../worker-threads-pool/lib/WorkerPool.js","../../../worker-threads-pool/lib/AggregatedPool.js","../../../worker-threads-pool/lib/index.js","../../../target-graph/lib/sortTargetsByPriority.js","../../../target-graph/lib/targetId.js","../../../target-graph/lib/detectCycles.js","../../../../node_modules/workspace-tools/lib/graph/getPackageDependencies.js","../../../../node_modules/workspace-tools/lib/graph/createDependencyMap.js","../../../target-graph/lib/expandDepSpecs.js","../../../target-graph/lib/prioritize.js","../../../target-graph/lib/TargetGraphBuilder.js","../../../target-graph/lib/getWeight.js","../../../target-graph/lib/TargetFactory.js","../../../target-graph/lib/WorkspaceTargetGraphBuilder.js","../../../target-graph/lib/index.js","../../../scheduler/lib/runners/TargetRunnerPicker.js","../../../scheduler/lib/workers/targetWorker.js","../../../scheduler/lib/runners/NoOpRunner.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    START_MARKER_PREFIX: ()=>START_MARKER_PREFIX,\n    END_MARKER_PREFIX: ()=>END_MARKER_PREFIX,\n    startMarker: ()=>startMarker,\n    endMarker: ()=>endMarker\n});\nconst START_MARKER_PREFIX = \"## WORKER:START:\";\nconst END_MARKER_PREFIX = \"## WORKER:END:\";\nfunction startMarker(id) {\n    return `${START_MARKER_PREFIX}${id}`;\n}\nfunction endMarker(id) {\n    return `${END_MARKER_PREFIX}${id}`;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"registerWorker\", {\n    enumerable: true,\n    get: ()=>registerWorker\n});\nconst _workerThreads = require(\"worker_threads\");\nconst _stdioStreamMarkersJs = require(\"./stdioStreamMarkers.js\");\nfunction registerWorker(fn) {\n    _workerThreads.parentPort?.on(\"message\", async (message)=>{\n        let abortController;\n        switch(message.type){\n            case \"start\":\n                abortController = new AbortController();\n                return message.task && await start(message.id, message.task, abortController.signal);\n            case \"abort\":\n                return abortController?.abort();\n            case \"check-memory-usage\":\n                return reportMemory(_workerThreads.parentPort);\n        }\n    });\n    async function start(workerTaskId, task, abortSignal) {\n        try {\n            process.stdout.write(`${(0, _stdioStreamMarkersJs.startMarker)(workerTaskId)}\\n`);\n            process.stderr.write(`${(0, _stdioStreamMarkersJs.startMarker)(workerTaskId)}\\n`);\n            const results = await fn(task, abortSignal);\n            _workerThreads.parentPort?.postMessage({\n                type: \"status\",\n                err: undefined,\n                results\n            });\n        } catch (err) {\n            _workerThreads.parentPort?.postMessage({\n                type: \"status\",\n                err,\n                results: undefined\n            });\n        } finally{\n            process.stdout.write(`${(0, _stdioStreamMarkersJs.endMarker)(workerTaskId)}\\n`);\n            process.stderr.write(`${(0, _stdioStreamMarkersJs.endMarker)(workerTaskId)}\\n`);\n        }\n    }\n    function reportMemory(port) {\n        const message = {\n            type: \"report-memory-usage\",\n            memoryUsage: process.memoryUsage().heapUsed\n        };\n        port.postMessage(message);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"createFilteredStreamTransform\", {\n    enumerable: true,\n    get: ()=>createFilteredStreamTransform\n});\nconst _stream = require(\"stream\");\nconst _stdioStreamMarkersJs = require(\"./stdioStreamMarkers.js\");\nfunction createFilteredStreamTransform() {\n    const transform = new _stream.Transform({\n        transform (chunk, _encoding, callback) {\n            let str = chunk.toString();\n            if (str.includes(_stdioStreamMarkersJs.START_MARKER_PREFIX)) {\n                str = str.replace(new RegExp(_stdioStreamMarkersJs.START_MARKER_PREFIX + \"[0-9a-z]{64}\\n\"), \"\");\n            }\n            if (str.includes(_stdioStreamMarkersJs.END_MARKER_PREFIX)) {\n                str = str.replace(new RegExp(_stdioStreamMarkersJs.END_MARKER_PREFIX + \"[0-9a-z]{64}\\n\"), \"\");\n            }\n            callback(null, str);\n        }\n    });\n    return transform;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"TaskInfo\", {\n    enumerable: true,\n    get: ()=>TaskInfo\n});\nconst _asyncHooks = require(\"async_hooks\");\nclass TaskInfo extends _asyncHooks.AsyncResource {\n    get id() {\n        return this.options.id;\n    }\n    get weight() {\n        return this.options.weight;\n    }\n    get abortSignal() {\n        return this.options.abortSignal;\n    }\n    done(err, results) {\n        const { cleanup , worker , resolve , reject  } = this.options;\n        if (cleanup) {\n            this.runInAsyncScope(cleanup, null, worker);\n        }\n        if (err) {\n            this.runInAsyncScope(reject, null, err, worker);\n        } else {\n            this.runInAsyncScope(resolve, null, results, worker);\n        }\n        this.emitDestroy();\n    }\n    constructor(options){\n        super(\"WorkerPoolTaskInfo\");\n        this.options = options;\n        if (options.setup) {\n            this.runInAsyncScope(options.setup, null, options.worker, options.worker.stdout, options.worker.stderr);\n        }\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"ThreadWorker\", {\n    enumerable: true,\n    get: ()=>ThreadWorker\n});\nconst _createFilteredStreamTransformJs = require(\"./createFilteredStreamTransform.js\");\nconst _readline = require(\"readline\");\nconst _stdioStreamMarkersJs = require(\"./stdioStreamMarkers.js\");\nconst _events = require(\"events\");\nconst _stream = require(\"stream\");\nconst _taskInfoJs = require(\"./TaskInfo.js\");\nconst _workerThreads = require(\"worker_threads\");\nconst _crypto = /*#__PURE__*/ _interopRequireDefault(require(\"crypto\"));\nconst _os = /*#__PURE__*/ _interopRequireDefault(require(\"os\"));\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n    if (privateCollection.has(obj)) {\n        throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n    }\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n    if (descriptor.get) {\n        return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n    if (descriptor.set) {\n        descriptor.set.call(receiver, value);\n    } else {\n        if (!descriptor.writable) {\n            throw new TypeError(\"attempted to set read only private field\");\n        }\n        descriptor.value = value;\n    }\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n    return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classPrivateFieldInit(obj, privateMap, value) {\n    _checkPrivateRedeclaration(obj, privateMap);\n    privateMap.set(obj, value);\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n    _classApplyDescriptorSet(receiver, descriptor, value);\n    return value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n}\nfunction _classPrivateMethodInit(obj, privateSet) {\n    _checkPrivateRedeclaration(obj, privateSet);\n    privateSet.add(obj);\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst workerFreeEvent = \"free\";\nvar _taskInfo = /*#__PURE__*/ new WeakMap(), _stdoutInfo = /*#__PURE__*/ new WeakMap(), _stderrInfo = /*#__PURE__*/ new WeakMap(), // @ts-ignore TS2564\n_worker = /*#__PURE__*/ new WeakMap(), _createNewWorker = /*#__PURE__*/ new WeakSet(), _ready = /*#__PURE__*/ new WeakSet(), _captureWorkerStdioStreams = /*#__PURE__*/ new WeakSet(), _handleAbort = /*#__PURE__*/ new WeakSet();\nclass ThreadWorker extends _events.EventEmitter {\n    start(work, abortSignal) {\n        this.status = \"busy\";\n        const { task , resolve , reject , cleanup , setup  } = work;\n        abortSignal?.addEventListener(\"abort\", _classPrivateMethodGet(this, _handleAbort, handleAbort));\n        const id = _crypto.default.randomBytes(32).toString(\"hex\");\n        _classPrivateFieldSet(this, _taskInfo, new _taskInfoJs.TaskInfo({\n            id,\n            weight: work.weight,\n            cleanup,\n            resolve,\n            reject,\n            worker: this,\n            setup,\n            abortSignal\n        }));\n        // Create a pair of promises that are only resolved when a specific task end marker is detected\n        // in the worker's stdout/stderr streams.\n        _classPrivateFieldGet(this, _stdoutInfo).promise = new Promise((onResolve)=>{\n            _classPrivateFieldGet(this, _stdoutInfo).resolve = onResolve;\n        });\n        _classPrivateFieldGet(this, _stderrInfo).promise = new Promise((onResolve)=>{\n            _classPrivateFieldGet(this, _stderrInfo).resolve = onResolve;\n        });\n        _classPrivateFieldGet(this, _worker).postMessage({\n            type: \"start\",\n            task: {\n                ...task,\n                weight: work.weight\n            },\n            id\n        });\n    }\n    get weight() {\n        return _classPrivateFieldGet(this, _taskInfo)?.weight ?? 1;\n    }\n    get stdout() {\n        return _classPrivateFieldGet(this, _stdoutInfo).stream;\n    }\n    get stderr() {\n        return _classPrivateFieldGet(this, _stderrInfo).stream;\n    }\n    get resourceLimits() {\n        return _classPrivateFieldGet(this, _worker).resourceLimits;\n    }\n    get threadId() {\n        return _classPrivateFieldGet(this, _worker).threadId;\n    }\n    terminate() {\n        _classPrivateFieldGet(this, _worker).removeAllListeners();\n        _classPrivateFieldGet(this, _worker).terminate();\n        _classPrivateFieldGet(this, _worker).unref();\n    }\n    restart() {\n        this.restarts++;\n        this.status = \"busy\";\n        _classPrivateFieldGet(this, _worker).terminate();\n        _classPrivateMethodGet(this, _createNewWorker, createNewWorker).call(this);\n    }\n    async checkMemoryUsage() {\n        _classPrivateFieldGet(this, _worker).postMessage({\n            type: \"check-memory-usage\"\n        });\n    }\n    constructor(script, options){\n        super();\n        _classPrivateMethodInit(this, _createNewWorker);\n        _classPrivateMethodInit(this, _ready);\n        _classPrivateMethodInit(this, _captureWorkerStdioStreams);\n        _classPrivateMethodInit(this, _handleAbort);\n        _classPrivateFieldInit(this, _taskInfo, {\n            writable: true,\n            value: void 0\n        });\n        _classPrivateFieldInit(this, _stdoutInfo, {\n            writable: true,\n            value: void 0\n        });\n        _classPrivateFieldInit(this, _stderrInfo, {\n            writable: true,\n            value: void 0\n        });\n        _classPrivateFieldInit(this, _worker, {\n            writable: true,\n            value: void 0\n        });\n        this.script = script;\n        this.options = options;\n        _classPrivateFieldSet(this, _stdoutInfo, {\n            stream: new _stream.Readable(),\n            promise: Promise.resolve(),\n            resolve: ()=>{}\n        });\n        _classPrivateFieldSet(this, _stderrInfo, {\n            stream: new _stream.Readable(),\n            promise: Promise.resolve(),\n            resolve: ()=>{}\n        });\n        this.status = \"busy\";\n        this.restarts = 0;\n        this.maxWorkerMemoryUsage = 0;\n        _classPrivateMethodGet(this, _createNewWorker, createNewWorker).call(this);\n    }\n}\nfunction createNewWorker() {\n    const { workerOptions  } = this.options;\n    const script = this.script;\n    const worker = new _workerThreads.Worker(script, {\n        ...workerOptions,\n        stdout: true,\n        stderr: true\n    });\n    _classPrivateMethodGet(this, _captureWorkerStdioStreams, captureWorkerStdioStreams).call(this, worker);\n    const filteredStdout = worker.stdout.pipe((0, _createFilteredStreamTransformJs.createFilteredStreamTransform)());\n    const filteredStderr = worker.stderr.pipe((0, _createFilteredStreamTransformJs.createFilteredStreamTransform)());\n    let capturedStdoutResolve = ()=>{};\n    const capturedStdoutPromise = new Promise((resolve)=>{\n        capturedStdoutResolve = resolve;\n        resolve();\n    });\n    let capturedStderrResolve = ()=>{};\n    const capturedStderrPromise = new Promise((resolve)=>{\n        capturedStderrResolve = resolve;\n        resolve();\n    });\n    const msgHandler = (data)=>{\n        if (data.type === \"status\") {\n            // In case of success: Call the callback that was passed to `runTask`,\n            // remove the `TaskInfo` associated with the Worker, and mark it as free\n            // again.\n            Promise.all([\n                _classPrivateFieldGet(this, _stdoutInfo).promise,\n                _classPrivateFieldGet(this, _stderrInfo).promise\n            ]).then(()=>{\n                const { err , results  } = data;\n                if (_classPrivateFieldGet(this, _taskInfo)) {\n                    _classPrivateFieldGet(this, _taskInfo).abortSignal?.removeEventListener(\"abort\", _classPrivateMethodGet(this, _handleAbort, handleAbort));\n                    _classPrivateFieldGet(this, _taskInfo).done(err, results);\n                }\n                this.checkMemoryUsage();\n            });\n        } else if (data.type === \"report-memory-usage\") {\n            this.maxWorkerMemoryUsage = Math.max(this.maxWorkerMemoryUsage, data.memoryUsage);\n            const limit = this.options.workerIdleMemoryLimit ?? _os.default.totalmem();\n            if (limit && data.memoryUsage > limit) {\n                this.restart();\n            } else {\n                _classPrivateMethodGet(this, _ready, ready).call(this);\n            }\n        }\n    };\n    worker.on(\"message\", msgHandler);\n    const errHandler = (err)=>{\n        Promise.all([\n            _classPrivateFieldGet(this, _stdoutInfo).promise,\n            _classPrivateFieldGet(this, _stderrInfo).promise\n        ]).then(()=>{\n            // In case of an uncaught exception: Call the callback that was passed to\n            // `runTask` with the error.\n            if (_classPrivateFieldGet(this, _taskInfo)) {\n                _classPrivateFieldGet(this, _taskInfo).done(err, null);\n            }\n            this.emit(\"error\", err);\n            this.restart();\n        });\n    };\n    // The 'error' event is emitted if the worker thread throws an uncaught exception. In that case, the worker is terminated.\n    worker.on(\"error\", errHandler);\n    _classPrivateFieldSet(this, _worker, worker);\n    _classPrivateFieldSet(this, _stdoutInfo, {\n        stream: filteredStdout,\n        promise: capturedStdoutPromise,\n        resolve: capturedStdoutResolve\n    });\n    _classPrivateFieldSet(this, _stderrInfo, {\n        stream: filteredStderr,\n        promise: capturedStderrPromise,\n        resolve: capturedStderrResolve\n    });\n    _classPrivateMethodGet(this, _ready, ready).call(this);\n}\nfunction ready() {\n    let weight = 1;\n    if (_classPrivateFieldGet(this, _taskInfo)) {\n        weight = _classPrivateFieldGet(this, _taskInfo).weight;\n        _classPrivateFieldSet(this, _taskInfo, undefined);\n    }\n    this.status = \"free\";\n    this.emit(workerFreeEvent, {\n        weight\n    });\n}\nfunction captureWorkerStdioStreams(worker) {\n    const stdout = worker.stdout;\n    const stdoutInterface = (0, _readline.createInterface)({\n        input: stdout,\n        crlfDelay: Infinity\n    });\n    const stderr = worker.stderr;\n    const stderrInterface = (0, _readline.createInterface)({\n        input: stderr,\n        crlfDelay: Infinity\n    });\n    // by the time we have a \"line\" event, we expect there to have been a this.#taskInfo\n    const lineHandlerFactory = (outputType)=>{\n        let lines = [];\n        let resolve;\n        return (line)=>{\n            if (!_classPrivateFieldGet(this, _taskInfo)) {\n                // Somehow this lineHandler function is called AFTER the worker has been freed.\n                // This can happen if there are stray setTimeout(), etc. with callbacks that outputs some messages in stdout/stderr\n                // In this case, we will ignore the output\n                return;\n            }\n            if (line.includes((0, _stdioStreamMarkersJs.startMarker)(_classPrivateFieldGet(this, _taskInfo).id))) {\n                lines = [];\n                if (outputType === \"stdout\") {\n                    resolve = _classPrivateFieldGet(this, _stdoutInfo).resolve;\n                } else {\n                    resolve = _classPrivateFieldGet(this, _stderrInfo).resolve;\n                }\n            } else if (line.includes((0, _stdioStreamMarkersJs.endMarker)(_classPrivateFieldGet(this, _taskInfo).id))) {\n                resolve();\n            } else {\n                lines.push(line);\n            }\n        };\n    };\n    const stdoutLineHandler = lineHandlerFactory(\"stdout\");\n    const stderrLineHandler = lineHandlerFactory(\"stderr\");\n    stdoutInterface.on(\"line\", stdoutLineHandler);\n    stderrInterface.on(\"line\", stderrLineHandler);\n}\nfunction handleAbort() {\n    _classPrivateFieldGet(this, _worker).postMessage({\n        type: \"abort\"\n    });\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"WorkerPool\", {\n    enumerable: true,\n    get: ()=>WorkerPool\n});\nconst _events = require(\"events\");\nconst _threadWorkerJs = require(\"./ThreadWorker.js\");\nconst _os = /*#__PURE__*/ _interopRequireDefault(require(\"os\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nconst workerFreedEvent = \"free\";\nclass WorkerPool extends _events.EventEmitter {\n    get workerRestarts() {\n        return this.workers.reduce((acc, worker)=>acc + worker.restarts, 0);\n    }\n    get maxWorkerMemoryUsage() {\n        return this.workers.reduce((acc, worker)=>Math.max(acc, worker.maxWorkerMemoryUsage), 0);\n    }\n    stats() {\n        return {\n            maxWorkerMemoryUsage: this.maxWorkerMemoryUsage,\n            workerRestarts: this.workerRestarts\n        };\n    }\n    ensureWorkers() {\n        if (this.workers.length === 0) {\n            for(let i = 0; i < this.maxWorkers; i++){\n                this.addNewWorker();\n            }\n        }\n    }\n    addNewWorker() {\n        const { script , workerOptions  } = this.options;\n        const worker = new _threadWorkerJs.ThreadWorker(script, {\n            workerOptions,\n            workerIdleMemoryLimit: this.options.workerIdleMemoryLimit\n        });\n        worker.on(\"free\", (data)=>{\n            const { weight  } = data;\n            this.availability += weight;\n            this.emit(workerFreedEvent);\n        });\n        this.workers.push(worker);\n    }\n    exec(task, weight, setup, cleanup, abortSignal) {\n        if (abortSignal?.aborted) {\n            return Promise.resolve();\n        }\n        // cull the weight of the task to be [1, maxWorkers]\n        weight = Math.min(Math.max(1, weight), this.maxWorkers);\n        return new Promise((resolve, reject)=>{\n            this.queue.push({\n                task: {\n                    ...task,\n                    weight\n                },\n                weight,\n                resolve,\n                reject,\n                cleanup,\n                setup\n            });\n            this._exec(abortSignal);\n        });\n    }\n    _exec(abortSignal) {\n        // find work that will fit the availability of workers\n        const workIndex = this.queue.findIndex((item)=>item.weight <= this.availability);\n        if (workIndex === -1) {\n            return;\n        }\n        // This is to immediate execute tasks if there ARE free workers\n        // If there are no free workers, the \"workerFreedEvent\" will call this function again to start the task\n        const worker = this.workers.find((w)=>w.status === \"free\");\n        if (worker) {\n            const work = this.queue[workIndex];\n            this.queue.splice(workIndex, 1);\n            this.availability -= work.weight;\n            worker.start(work, abortSignal);\n        }\n    }\n    async close() {\n        await Promise.all(this.workers.map((worker)=>worker.terminate()));\n    }\n    constructor(options){\n        super();\n        this.options = options;\n        this.workers = [];\n        this.freeWorkers = [];\n        this.queue = [];\n        this.maxWorkers = 0;\n        this.availability = 0;\n        this.maxWorkers = this.options.maxWorkers ?? _os.default.cpus().length - 1;\n        this.availability = this.maxWorkers;\n        this.workers = [];\n        this.freeWorkers = [];\n        this.queue = [];\n        this.ensureWorkers();\n        // Any time the workerFreedEvent is emitted, dispatch\n        // the next task pending in the queue, if any.\n        this.on(workerFreedEvent, ()=>{\n            if (this.queue.length > 0) {\n                this._exec();\n            }\n        });\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"AggregatedPool\", {\n    enumerable: true,\n    get: ()=>AggregatedPool\n});\nconst _workerPoolJs = require(\"./WorkerPool.js\");\nclass AggregatedPool {\n    stats() {\n        const stats = [\n            ...this.groupedPools.values(),\n            this.defaultPool\n        ].reduce((acc, pool)=>{\n            if (pool) {\n                const poolStats = pool.stats();\n                acc.maxWorkerMemoryUsage = Math.max(acc.maxWorkerMemoryUsage, poolStats.maxWorkerMemoryUsage);\n                acc.workerRestarts = acc.workerRestarts + poolStats.workerRestarts;\n            }\n            return acc;\n        }, {\n            maxWorkerMemoryUsage: 0,\n            workerRestarts: 0\n        });\n        return stats;\n    }\n    async exec(data, weight, setup, cleanup, abortSignal) {\n        const group = this.options.groupBy(data);\n        const pool = this.groupedPools.get(group) ?? this.defaultPool;\n        if (!pool) {\n            throw new Error(`No pool found to be able to run ${group} tasks, try adjusting the maxWorkers & concurrency values`);\n        }\n        return pool.exec(data, weight, setup, cleanup, abortSignal);\n    }\n    async close() {\n        const promises = [\n            ...this.groupedPools.values(),\n            this.defaultPool\n        ].map((pool)=>pool?.close());\n        return Promise.all(promises);\n    }\n    constructor(options){\n        this.options = options;\n        this.groupedPools = new Map();\n        const { maxWorkers , maxWorkersByGroup , script , workerOptions  } = options;\n        let totalGroupedWorkers = 0;\n        for (const [group, groupMaxWorkers] of maxWorkersByGroup.entries()){\n            const pool = new _workerPoolJs.WorkerPool({\n                maxWorkers: groupMaxWorkers,\n                workerOptions,\n                script,\n                workerIdleMemoryLimit: options.workerIdleMemoryLimit\n            });\n            this.groupedPools.set(group, pool);\n            totalGroupedWorkers += groupMaxWorkers;\n        }\n        if (totalGroupedWorkers > maxWorkers) {\n            throw new Error(`Total maxWorkers (${totalGroupedWorkers}) configured across all groups exceeds concurrency (${maxWorkers}). Try reducing the maxWorkers, or increasing the --concurrency CLI argument, or separate the tasks to be run`);\n        }\n        const defaultPoolWorkersCount = maxWorkers - totalGroupedWorkers;\n        if (defaultPoolWorkersCount > 0) {\n            this.defaultPool = new _workerPoolJs.WorkerPool({\n                maxWorkers: defaultPoolWorkersCount,\n                workerOptions,\n                script,\n                workerIdleMemoryLimit: options.workerIdleMemoryLimit\n            });\n        }\n        this.options.logger.verbose(`Workers pools created:  ${[\n            ...maxWorkersByGroup.entries(),\n            [\n                \"default\",\n                defaultPoolWorkersCount\n            ]\n        ].map(([group, count])=>`${group} (${count})`).join(\", \")}`);\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    registerWorker: ()=>_registerWorkerJs.registerWorker,\n    WorkerPool: ()=>_workerPoolJs.WorkerPool,\n    AggregatedPool: ()=>_aggregatedPoolJs.AggregatedPool\n});\nconst _registerWorkerJs = require(\"./registerWorker.js\");\nconst _workerPoolJs = require(\"./WorkerPool.js\");\nconst _aggregatedPoolJs = require(\"./AggregatedPool.js\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"sortTargetsByPriority\", {\n    enumerable: true,\n    get: ()=>sortTargetsByPriority\n});\nfunction sortTargetsByPriority(targets) {\n    return targets.sort((a, b)=>{\n        return (b.priority ?? 0) - (a.priority ?? 0);\n    });\n}\n","/**\n * Generates a unique target id in this format: `<package-name>#<task-name>` or `//#<task-name>`\n *\n * @param pkgName\n * @param task\n * @returns\n */ \"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getTargetId: ()=>getTargetId,\n    getPackageAndTask: ()=>getPackageAndTask,\n    getStartTargetId: ()=>getStartTargetId\n});\nfunction getTargetId(pkgName, task) {\n    return `${typeof pkgName === \"string\" ? pkgName : \"\"}#${task}`;\n}\nfunction getPackageAndTask(targetId) {\n    if (targetId.includes(\"#\")) {\n        const parts = targetId.split(\"#\");\n        // `//#<task-name>` or `#<task-name>` means root by convention\n        if (targetId.startsWith(\"#\") || parts[0] === \"//\") {\n            return {\n                packageName: undefined,\n                task: parts[1]\n            };\n        }\n        return {\n            packageName: parts[0],\n            task: parts[1]\n        };\n    } else {\n        return {\n            packageName: undefined,\n            task: targetId\n        };\n    }\n}\nconst START_TARGET_ID = \"__start\";\nfunction getStartTargetId() {\n    return START_TARGET_ID;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"detectCycles\", {\n    enumerable: true,\n    get: ()=>detectCycles\n});\nfunction detectCycles(targets) {\n    /**\n   *  A map to keep track of the visited and visiting nodes.\n   * <node, true> entry means it is currently being visited.\n   * <node, false> entry means it's sub graph has been visited and is a DAG.\n   * No entry means the node has not been visited yet.\n   */ const visitMap = new Map();\n    for (const [nodeId] of targets.entries()){\n        /**\n     * Test whether this node has already been visited or not.\n     */ if (!visitMap.has(nodeId)) {\n            /**\n       * Test whether the sub-graph of this node has cycles.\n       */ const cycle = searchForCycleDFS(targets, visitMap, nodeId);\n            if (cycle.length > 0) {\n                return {\n                    hasCycle: true,\n                    cycle\n                };\n            }\n        }\n    }\n    return {\n        hasCycle: false\n    };\n}\nconst searchForCycleDFS = (graph, visitMap, nodeId)=>{\n    const stack = [\n        {\n            node: nodeId,\n            traversing: false\n        }\n    ];\n    while(stack.length > 0){\n        const current = stack[stack.length - 1];\n        if (!current.traversing) {\n            if (visitMap.has(current.node)) {\n                if (visitMap.get(current.node)) {\n                    /**\n           * The current node has already been visited,\n           * hence there is a cycle.\n           */ const listOfCycle = stack.filter((i)=>i.traversing).map((a)=>a.node);\n                    return listOfCycle.slice(listOfCycle.indexOf(current.node));\n                } else {\n                    /**\n           * The current node has already been fully traversed\n           */ stack.pop();\n                    continue;\n                }\n            }\n            /**\n       * The current node is starting its traversal\n       */ visitMap.set(current.node, true);\n            stack[stack.length - 1] = {\n                ...current,\n                traversing: true\n            };\n            /**\n       * Get the current node in the graph\n       */ const node = graph.get(current.node);\n            if (!node) {\n                throw new Error(`Could not find node \"${current.node}\" in the graph`);\n            }\n            /**\n       * Add the current node's dependents to the stack\n       */ stack.push(...[\n                ...node.dependents\n            ].map((n)=>({\n                    node: n,\n                    traversing: false\n                })));\n        } else {\n            /**\n       * The current node has now been fully traversed.\n       */ visitMap.set(current.node, false);\n            stack.pop();\n        }\n    }\n    return [];\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPackageDependencies = void 0;\nfunction getPackageDependencies(info, packages, options = { withDevDependencies: true }) {\n    const deps = {\n        ...info.dependencies,\n        ...(options.withDevDependencies && info.devDependencies),\n        ...(options.withPeerDependencies && info.peerDependencies),\n    };\n    return Object.keys(packages).filter((pkg) => !!deps[pkg]);\n}\nexports.getPackageDependencies = getPackageDependencies;\n//# sourceMappingURL=getPackageDependencies.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createDependencyMap = void 0;\nconst getPackageDependencies_1 = require(\"./getPackageDependencies\");\nfunction createDependencyMap(packages, options = { withDevDependencies: true, withPeerDependencies: false }) {\n    const map = {\n        dependencies: new Map(),\n        dependents: new Map(),\n    };\n    for (const [pkg, info] of Object.entries(packages)) {\n        const deps = (0, getPackageDependencies_1.getPackageDependencies)(info, packages, options);\n        for (const dep of deps) {\n            if (!map.dependencies.has(pkg)) {\n                map.dependencies.set(pkg, new Set());\n            }\n            map.dependencies.get(pkg).add(dep);\n            if (!map.dependents.has(dep)) {\n                map.dependents.set(dep, new Set());\n            }\n            map.dependents.get(dep).add(pkg);\n        }\n    }\n    return map;\n}\nexports.createDependencyMap = createDependencyMap;\n//# sourceMappingURL=createDependencyMap.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"expandDepSpecs\", {\n    enumerable: true,\n    get: ()=>expandDepSpecs\n});\nconst _targetIdJs = require(\"./targetId.js\");\nfunction expandDepSpecs(targets, dependencyMap) {\n    const dependencies = [];\n    /**\n   * Adds a dependency in the form of [from, to] to the dependency list.\n   * @param from\n   * @param to\n   */ const addDependency = (from, to)=>{\n        dependencies.push([\n            from,\n            to\n        ]);\n    };\n    /**\n   * Finds all transitive dependencies, given a task and optionally a dependency list.\n   * @param task\n   * @param dependencies\n   * @returns\n   */ const findDependenciesByTask = (task, dependencies)=>{\n        if (!dependencies) {\n            return targetList.filter((needle)=>needle.task === task).map((needle)=>needle.id);\n        }\n        return targetList.filter((needle)=>{\n            const { task: needleTask , packageName: needlePackageName  } = needle;\n            return needleTask === task && dependencies.some((depPkg)=>depPkg === needlePackageName);\n        }).map((needle)=>needle.id);\n    };\n    const targetList = [\n        ...targets.values()\n    ];\n    for (const target of targetList){\n        const { depSpecs , packageName , id: to  } = target;\n        // Always start with a root node with a special \"START_TARGET_ID\"\n        // because any node could potentially be part of the entry point in building the scoped target subgraph\n        dependencies.push([\n            (0, _targetIdJs.getStartTargetId)(),\n            to\n        ]);\n        // Skip any targets that have no \"deps\" specified\n        if (!depSpecs || depSpecs.length === 0) {\n            continue;\n        }\n        /**\n     * Now for every deps defined, we need to \"interpret\" it based on the syntax:\n     * - for any deps like package#task, we simply add the singular dependency (source could be a single package or all packages)\n     * - for anything that starts with a \"^\", we add the package-tasks according to the topological package graph\n     *    NOTE: in a non-strict mode (TODO), the dependencies can come from transitive task dependencies\n     * - for anything that starts with a \"^^\", we add the package-tasks from the transitive dependencies in the topological\n     *    package graph.\n     * - for {\"pkgA#task\": [\"dep\"]}, we interpret to add \"pkgA#dep\"\n     * - for anything that is a string without a \"^\", we treat that string as the name of a task, adding all targets that way\n     *    NOTE: in a non-strict mode (TODO), the dependencies can come from transitive task dependencies\n     *\n     * We interpret anything outside of these conditions as invalid\n     */ for (const dependencyTargetId of depSpecs){\n            if (dependencyTargetId.includes(\"#\")) {\n                // id's with a # are package-task dependencies, or global\n                // therefore, we must use getPackageAndTask() & getTargetId() to normalize the target id\n                // (e.g. \"build\": [\"build-tool#build\"])\n                const { packageName , task  } = (0, _targetIdJs.getPackageAndTask)(dependencyTargetId);\n                const normalizedDependencyTargetId = (0, _targetIdJs.getTargetId)(packageName, task);\n                addDependency(normalizedDependencyTargetId, to);\n            } else if (dependencyTargetId.startsWith(\"^^\") && packageName) {\n                // Transitive depdency (e.g. bundle: ['^^transpile'])\n                const depTask = dependencyTargetId.substring(2);\n                const targetDependencies = [\n                    ...getTransitiveGraphDependencies(packageName, dependencyMap) ?? []\n                ];\n                const dependencyTargetIds = findDependenciesByTask(depTask, targetDependencies);\n                for (const from of dependencyTargetIds){\n                    addDependency(from, to);\n                }\n            } else if (dependencyTargetId.startsWith(\"^\") && packageName) {\n                // Topological dependency (e.g. build: ['^build'])\n                const depTask = dependencyTargetId.substring(1);\n                const targetDependencies = [\n                    ...dependencyMap.dependencies.get(packageName) ?? []\n                ];\n                const dependencyTargetIds = findDependenciesByTask(depTask, targetDependencies);\n                for (const from of dependencyTargetIds){\n                    addDependency(from, to);\n                }\n            } else if (packageName) {\n                // Add dependency on a specific package and given task name as dependency\n                // (e.g. bundle: ['build'])\n                const task = dependencyTargetId;\n                if (targets.has((0, _targetIdJs.getTargetId)(packageName, task))) {\n                    addDependency((0, _targetIdJs.getTargetId)(packageName, task), to);\n                }\n            } else if (!dependencyTargetId.startsWith(\"^\")) {\n                // Global dependency - add all targets that match task name as dependency\n                // (e.g. \"#bundle\": ['build'])\n                const task = dependencyTargetId;\n                const dependencyIds = findDependenciesByTask(task);\n                for (const dependencyId of dependencyIds){\n                    addDependency(dependencyId, to);\n                }\n            } else {\n                throw new Error(`invalid pipeline config detected: ${target.id}, packageName: ${packageName}, dep: ${dependencyTargetId}`);\n            }\n        }\n    }\n    return dependencies;\n}\n/** Cached transitive task dependency */ const cachedTransitiveTaskDependencies = new Map();\n/**\n * Gets a list of package names that are direct or indirect dependencies of rootPackageName in this.graph,\n * and caches them on the Pipeline.\n *\n * For example, this is useful for a bundling target that depends on all transitive dependencies to have been built.\n *\n * @param packageName the root package to begin walking from\n */ function getTransitiveGraphDependencies(packageName, dependencyMap) {\n    const cachedResult = cachedTransitiveTaskDependencies.get(packageName);\n    if (cachedResult) {\n        return cachedResult === \"walk-in-progress\" ? // If we hit this case, that means that a dependency of this package depends on it.\n        //\n        // In this case we return an empty set to omit this package and it's downstream from its\n        // dependency\n        new Set() : cachedResult;\n    } else {\n        // No cached result. Compute now with a recursive walk\n        // mark that we are traversing this package to prevent infinite recursion\n        // in cases of circular dependencies\n        cachedTransitiveTaskDependencies.set(packageName, \"walk-in-progress\");\n        const immediateDependencies = [\n            ...dependencyMap.dependencies.get(packageName) ?? []\n        ];\n        // build the set of transitive dependencies by recursively walking the\n        // immediate dependencies' dependencies.\n        const transitiveDepSet = new Set(immediateDependencies);\n        for (const immediateDependency of immediateDependencies){\n            for (const transitiveSubDependency of getTransitiveGraphDependencies(immediateDependency, dependencyMap)){\n                transitiveDepSet.add(transitiveSubDependency);\n            }\n        }\n        // Cache the result and return\n        cachedTransitiveTaskDependencies.set(packageName, transitiveDepSet);\n        return transitiveDepSet;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"prioritize\", {\n    enumerable: true,\n    get: ()=>prioritize\n});\nfunction getNodesWithNoDependencies(targets) {\n    const nodesWithNoDependencies = [];\n    for (const [id, target] of targets){\n        if (target.dependencies.length === 0) {\n            nodesWithNoDependencies.push(id);\n        }\n    }\n    return nodesWithNoDependencies;\n}\n/** Creates a map of node ids to a set of all the nodes this node depends on. This creates a new copy of the set to enable duplication */ function getNewDependsOnMap(pGraphDependencyMap) {\n    return new Map([\n        ...pGraphDependencyMap.entries()\n    ].map(([key, value])=>[\n            key,\n            new Set(value.dependencies)\n        ]));\n}\n/**\n * Topologically sort the nodes in a graph - starting with nodes with no dependencies\n * @returns a list of ids in order\n */ function topologicalSort(targets, nodesWithNoDependencies) {\n    const sortedList = [];\n    const dependsOnMap = getNewDependsOnMap(targets);\n    const nodesWithNoDependenciesClone = [\n        ...nodesWithNoDependencies\n    ];\n    while(nodesWithNoDependenciesClone.length > 0){\n        const currentId = nodesWithNoDependenciesClone.pop();\n        sortedList.push(currentId);\n        const node = targets.get(currentId);\n        // Update the depends on maps of all outgoing edges\n        node.dependents.forEach((childId)=>{\n            const childNode = dependsOnMap.get(childId);\n            childNode.delete(currentId);\n            // If this item is now unblocked, put it on the unblocked list\n            if (childNode.size === 0) {\n                nodesWithNoDependenciesClone.push(childId);\n            }\n        });\n    }\n    return sortedList;\n}\nfunction prioritize(targets) {\n    const nodeCumulativePriorities = new Map();\n    const nodesWithNoDependencies = getNodesWithNoDependencies(targets);\n    const topoSortedNodeIds = topologicalSort(targets, nodesWithNoDependencies);\n    /**\n   * What is this loop doing?\n   *\n   * Now that we have topologically sorted the nodes, we examine the each node\n   * and update the cumulative priority of all the nodes that depend on it.\n   */ for (const currentNodeId of topoSortedNodeIds){\n        const node = targets.get(currentNodeId);\n        // The default priority for a node is zero\n        const currentNodePriority = node.priority || 0;\n        const childrenPriorities = node.dependencies.map((childId)=>{\n            const childCumulativePriority = nodeCumulativePriorities.get(childId);\n            if (childCumulativePriority === undefined) {\n                throw new Error(`Expected to have already computed the cumulative priority for node ${childId}`);\n            }\n            return childCumulativePriority;\n        });\n        const maxChildCumulativePriority = Math.max(...childrenPriorities, 0);\n        const result = currentNodePriority + maxChildCumulativePriority;\n        nodeCumulativePriorities.set(currentNodeId, result);\n    }\n    // Set the priority of each node to the cumulative priority\n    for (const target of targets.values()){\n        const cumulativePriority = nodeCumulativePriorities.get(target.id);\n        if (cumulativePriority === undefined) {\n            throw new Error(`Expected to have already computed the cumulative priority for node ${target.id}`);\n        }\n        target.priority = cumulativePriority;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"TargetGraphBuilder\", {\n    enumerable: true,\n    get: ()=>TargetGraphBuilder\n});\nconst _targetIdJs = require(\"./targetId.js\");\nconst _prioritizeJs = require(\"./prioritize.js\");\nconst _detectCyclesJs = require(\"./detectCycles.js\");\nclass TargetGraphBuilder {\n    addTarget(target) {\n        this.targets.set(target.id, target);\n        this.addDependency((0, _targetIdJs.getStartTargetId)(), target.id);\n        return target;\n    }\n    addDependency(dependency, dependent) {\n        if (this.targets.has(dependent)) {\n            const target = this.targets.get(dependent);\n            if (!target.dependencies.includes(dependency)) {\n                target.dependencies.push(dependency);\n            }\n        }\n        if (this.targets.has(dependency)) {\n            const target = this.targets.get(dependency);\n            if (!target.dependents.includes(dependent)) {\n                target.dependents.push(dependent);\n            }\n        }\n    }\n    /**\n   * Builds a target graph for given tasks and packages\n   */ build() {\n        // Ensure we do not have cycles in the subgraph\n        const cycleInfo = (0, _detectCyclesJs.detectCycles)(this.targets);\n        if (cycleInfo.hasCycle) {\n            throw new Error(\"Cycles detected in the target graph: \" + cycleInfo.cycle.concat(cycleInfo.cycle[0]).join(\" -> \"));\n        }\n        // The full graph might produce a different aggregated priority value for a target\n        (0, _prioritizeJs.prioritize)(this.targets);\n        return {\n            targets: this.targets\n        };\n    }\n    subgraph(entriesTargetIds) {\n        const subgraphBuilder = new TargetGraphBuilder();\n        const visited = [];\n        const queue = [];\n        for (const targetId of entriesTargetIds){\n            if (this.targets.has(targetId)) {\n                const target = this.targets.get(targetId);\n                subgraphBuilder.addTarget({\n                    ...target,\n                    dependencies: [],\n                    dependents: []\n                });\n                queue.push(targetId);\n            }\n        }\n        while(queue.length > 0){\n            const targetId = queue.shift();\n            if (visited.includes(targetId)) {\n                continue;\n            }\n            visited.push(targetId);\n            const target = this.targets.get(targetId);\n            if (!target) {\n                throw new Error(\"Subgraph builder failed - target not found: \" + targetId);\n            }\n            for (const dependency of target.dependencies){\n                if (dependency !== (0, _targetIdJs.getStartTargetId)()) {\n                    if (!subgraphBuilder.targets.has(dependency)) {\n                        subgraphBuilder.addTarget({\n                            ...this.targets.get(dependency),\n                            dependencies: [],\n                            dependents: []\n                        });\n                    }\n                    subgraphBuilder.addDependency(dependency, targetId);\n                }\n                queue.push(dependency);\n            }\n        }\n        return subgraphBuilder.build();\n    }\n    /**\n   * Initializes the builder with package infos\n   */ constructor(){\n        /** A map of targets - used internally for looking up generated targets from the target configurations */ this.targets = new Map();\n        const startId = (0, _targetIdJs.getStartTargetId)();\n        this.targets.set(startId, {\n            id: startId,\n            task: startId,\n            cwd: \"\",\n            label: \"Start\",\n            hidden: true,\n            dependencies: [],\n            dependents: [],\n            depSpecs: [],\n            weight: 1,\n            priority: 0\n        });\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"getWeight\", {\n    enumerable: true,\n    get: ()=>getWeight\n});\nfunction getWeight(target, weight, maxWorkers) {\n    if (typeof weight === \"number\") {\n        return weight;\n    } else if (typeof weight === \"function\") {\n        return weight(target, maxWorkers);\n    }\n    return 1;\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"TargetFactory\", {\n    enumerable: true,\n    get: ()=>TargetFactory\n});\nconst _targetIdJs = require(\"./targetId.js\");\nconst _getWeightJs = require(\"./getWeight.js\");\nclass TargetFactory {\n    /**\n   * Creates a package task `Target`\n   * @param packageName\n   * @param task\n   * @param config\n   * @returns a package task `Target`\n   */ createPackageTarget(packageName, task, config) {\n        const { resolve  } = this.options;\n        const { options , deps , dependsOn , cache , inputs , outputs , priority , maxWorkers , environmentGlob , weight  } = config;\n        const cwd = resolve(packageName);\n        const target = {\n            id: (0, _targetIdJs.getTargetId)(packageName, task),\n            label: `${packageName} - ${task}`,\n            type: config.type,\n            packageName,\n            task,\n            cache: cache !== false,\n            cwd,\n            depSpecs: dependsOn ?? deps ?? [],\n            dependencies: [],\n            dependents: [],\n            inputs,\n            outputs,\n            priority,\n            maxWorkers,\n            environmentGlob,\n            weight: 1,\n            options\n        };\n        target.weight = (0, _getWeightJs.getWeight)(target, weight, maxWorkers);\n        return target;\n    }\n    createGlobalTarget(id, config) {\n        const { root  } = this.options;\n        const { options , deps , dependsOn , inputs , outputs , priority , maxWorkers , environmentGlob , weight  } = config;\n        const { task  } = (0, _targetIdJs.getPackageAndTask)(id);\n        const target = {\n            id,\n            label: id,\n            type: config.type,\n            task,\n            cache: false,\n            cwd: root,\n            depSpecs: dependsOn ?? deps ?? [],\n            dependencies: [],\n            dependents: [],\n            inputs,\n            outputs,\n            priority,\n            maxWorkers,\n            environmentGlob,\n            weight: 1,\n            options\n        };\n        target.weight = (0, _getWeightJs.getWeight)(target, weight, maxWorkers);\n        return target;\n    }\n    constructor(options){\n        this.options = options;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"WorkspaceTargetGraphBuilder\", {\n    enumerable: true,\n    get: ()=>WorkspaceTargetGraphBuilder\n});\nconst _createDependencyMapJs = require(\"workspace-tools/lib/graph/createDependencyMap.js\");\nconst _targetIdJs = require(\"./targetId.js\");\nconst _expandDepSpecsJs = require(\"./expandDepSpecs.js\");\nconst _path = /*#__PURE__*/ _interopRequireDefault(require(\"path\"));\nconst _targetGraphBuilderJs = require(\"./TargetGraphBuilder.js\");\nconst _targetFactoryJs = require(\"./TargetFactory.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nclass WorkspaceTargetGraphBuilder {\n    /**\n   * Generates new `Target`, indexed by the id based on a new target configuration.\n   *\n   * @param id\n   * @param targetDefinition\n   */ addTargetConfig(id, config = {}) {\n        // Generates a target definition from the target config\n        if (id.startsWith(\"//\") || id.startsWith(\"#\")) {\n            const target = this.targetFactory.createGlobalTarget(id, config);\n            this.graphBuilder.addTarget(target);\n        } else if (id.includes(\"#\")) {\n            const { packageName , task  } = (0, _targetIdJs.getPackageAndTask)(id);\n            const target = this.targetFactory.createPackageTarget(packageName, task, config);\n            this.graphBuilder.addTarget(target);\n        } else {\n            const packages = Object.keys(this.packageInfos);\n            for (const packageName of packages){\n                const task = id;\n                const target = this.targetFactory.createPackageTarget(packageName, task, config);\n                this.graphBuilder.addTarget(target);\n            }\n        }\n    }\n    /**\n   * Builds a scoped target graph for given tasks and packages\n   *\n   * Steps:\n   * 1. expands the dependency specs from the target definitions\n   * 2. sub-graph filtered from the full dependency graph\n   * 3. filtering all targets to just only the ones listed in the sub-graph\n   * 4. returns the sub-graph\n   *\n   * @param tasks\n   * @param scope\n   * @returns\n   */ build(tasks, scope) {\n        // Expands the dependency specs from the target definitions\n        const fullDependencies = (0, _expandDepSpecsJs.expandDepSpecs)(this.graphBuilder.targets, this.dependencyMap);\n        for (const [from, to] of fullDependencies){\n            this.graphBuilder.addDependency(from, to);\n        }\n        const subGraphEntries = [];\n        for (const task of tasks){\n            if (scope) {\n                for (const packageName of scope){\n                    subGraphEntries.push((0, _targetIdJs.getTargetId)(packageName, task));\n                }\n            } else {\n                for (const packageName of Object.keys(this.packageInfos)){\n                    subGraphEntries.push((0, _targetIdJs.getTargetId)(packageName, task));\n                }\n            }\n        }\n        const subGraph = this.graphBuilder.subgraph(subGraphEntries);\n        return {\n            targets: subGraph.targets\n        };\n    }\n    /**\n   * Initializes the builder with package infos\n   * @param root the root directory of the workspace\n   * @param packageInfos the package infos for the workspace\n   */ constructor(root, packageInfos){\n        this.packageInfos = packageInfos;\n        this.dependencyMap = (0, _createDependencyMapJs.createDependencyMap)(packageInfos, {\n            withDevDependencies: true,\n            withPeerDependencies: false\n        });\n        this.graphBuilder = new _targetGraphBuilderJs.TargetGraphBuilder();\n        this.targetFactory = new _targetFactoryJs.TargetFactory({\n            root: root,\n            resolve (packageName) {\n                return _path.default.dirname(packageInfos[packageName].packageJsonPath);\n            }\n        });\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    sortTargetsByPriority: ()=>_sortTargetsByPriorityJs.sortTargetsByPriority,\n    getTargetId: ()=>_targetIdJs.getTargetId,\n    getStartTargetId: ()=>_targetIdJs.getStartTargetId,\n    detectCycles: ()=>_detectCyclesJs.detectCycles,\n    WorkspaceTargetGraphBuilder: ()=>_workspaceTargetGraphBuilderJs.WorkspaceTargetGraphBuilder,\n    TargetGraphBuilder: ()=>_targetGraphBuilderJs.TargetGraphBuilder,\n    TargetFactory: ()=>_targetFactoryJs.TargetFactory\n});\nconst _sortTargetsByPriorityJs = require(\"./sortTargetsByPriority.js\");\nconst _targetIdJs = require(\"./targetId.js\");\nconst _detectCyclesJs = require(\"./detectCycles.js\");\nconst _workspaceTargetGraphBuilderJs = require(\"./WorkspaceTargetGraphBuilder.js\");\nconst _targetGraphBuilderJs = require(\"./TargetGraphBuilder.js\");\nconst _targetFactoryJs = require(\"./TargetFactory.js\");\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"TargetRunnerPicker\", {\n    enumerable: true,\n    get: ()=>TargetRunnerPicker\n});\nconst _path = /*#__PURE__*/ _interopRequireDefault(require(\"path\"));\nconst _targetGraph = require(\"@lage-run/target-graph\");\nconst _url = require(\"url\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nclass TargetRunnerPicker {\n    async pick(target) {\n        if (target.id === (0, _targetGraph.getStartTargetId)()) {\n            return (await import(\"./NoOpRunner.js\")).NoOpRunner;\n        }\n        if (!target.type) {\n            target.type = \"npmScript\";\n        }\n        if (this.options[target.type]) {\n            const config = this.options[target.type];\n            const { script , options  } = config;\n            let importScript = script;\n            if (!importScript.startsWith(\"file://\")) {\n                importScript = (0, _url.pathToFileURL)(importScript).toString();\n            }\n            const runnerModule = await import(importScript);\n            const base = _path.default.basename(script);\n            const runnerName = base.replace(_path.default.extname(base), \"\");\n            const runner = typeof runnerModule[runnerName] === \"function\" ? runnerModule[runnerName] : typeof runnerModule.default === \"function\" ? runnerModule.default : typeof runnerModule.default[runnerName] === \"function\" ? runnerModule.default[runnerName] : runnerModule;\n            return new runner(options);\n        }\n        throw new Error(`No runner found for target ${target.id}`);\n    }\n    constructor(options){\n        this.options = options;\n    }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nconst _workerThreadsPool = require(\"@lage-run/worker-threads-pool\");\nconst _targetRunnerPickerJs = require(\"../runners/TargetRunnerPicker.js\");\nconst _workerThreads = require(\"worker_threads\");\nfunction setup(options) {\n    const { runners  } = options;\n    const runnerPicker = new _targetRunnerPickerJs.TargetRunnerPicker(runners);\n    return {\n        runnerPicker\n    };\n}\nconst { runnerPicker  } = setup(_workerThreads.workerData);\nasync function run(data, abortSignal) {\n    const runner = await runnerPicker.pick(data.target);\n    await runner.run({\n        ...data,\n        abortSignal\n    });\n}\n(0, _workerThreadsPool.registerWorker)(run);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"NoOpRunner\", {\n    enumerable: true,\n    get: ()=>NoOpRunner\n});\nconst NoOpRunner = {\n    async shouldRun () {\n        return true;\n    },\n    async run () {\n    // pass\n    }\n};\n"],"names":["Object","defineProperty","exports","value","target","all","name","enumerable","get","_export","START_MARKER_PREFIX","END_MARKER_PREFIX","startMarker","endMarker","id","registerWorker","_workerThreads","require$$0","_stdioStreamMarkersJs","require$$1","fn","parentPort","on","async","message","abortController","type","AbortController","task","workerTaskId","abortSignal","process","stdout","write","stderr","results","postMessage","err","undefined","start","signal","abort","port","memoryUsage","heapUsed","reportMemory","createFilteredStreamTransform","_stream","Transform","transform","chunk","_encoding","callback","str","toString","includes","replace","RegExp","TaskInfo","_asyncHooks","AsyncResource","this","options","weight","done","cleanup","worker","resolve","reject","runInAsyncScope","emitDestroy","constructor","super","setup","ThreadWorker","_createFilteredStreamTransformJs","_readline","require$$2","_events","require$$3","require$$4","_taskInfoJs","require$$5","require$$6","_crypto","_interopRequireDefault","require$$7","_os","require$$8","_checkPrivateRedeclaration","obj","privateCollection","has","TypeError","_classExtractFieldDescriptor","receiver","privateMap","action","_classPrivateFieldGet","descriptor","call","_classApplyDescriptorGet","_classPrivateFieldInit","set","_classPrivateFieldSet","writable","_classApplyDescriptorSet","_classPrivateMethodGet","privateSet","_classPrivateMethodInit","add","__esModule","default","workerFreeEvent","_taskInfo","WeakMap","_stdoutInfo","_stderrInfo","_worker","_createNewWorker","WeakSet","_ready","_captureWorkerStdioStreams","_handleAbort","EventEmitter","work","status","addEventListener","handleAbort","randomBytes","promise","Promise","onResolve","stream","resourceLimits","threadId","terminate","removeAllListeners","unref","restart","restarts","createNewWorker","script","Readable","maxWorkerMemoryUsage","workerOptions","Worker","captureWorkerStdioStreams","filteredStdout","pipe","filteredStderr","capturedStdoutResolve","capturedStdoutPromise","capturedStderrResolve","capturedStderrPromise","data","then","removeEventListener","checkMemoryUsage","Math","max","limit","workerIdleMemoryLimit","totalmem","ready","emit","stdoutInterface","createInterface","input","crlfDelay","Infinity","stderrInterface","lineHandlerFactory","outputType","lines","line","push","stdoutLineHandler","stderrLineHandler","WorkerPool","_threadWorkerJs","workerFreedEvent","workerRestarts","workers","reduce","acc","stats","ensureWorkers","length","i","maxWorkers","addNewWorker","availability","exec","aborted","min","queue","_exec","workIndex","findIndex","item","find","w","splice","map","freeWorkers","cpus","AggregatedPool","_workerPoolJs","groupedPools","values","defaultPool","pool","poolStats","group","groupBy","Error","promises","close","Map","maxWorkersByGroup","totalGroupedWorkers","groupMaxWorkers","entries","defaultPoolWorkersCount","logger","verbose","count","join","_registerWorkerJs","_aggregatedPoolJs","sortTargetsByPriority","targets","sort","a","b","priority","getTargetId","pkgName","getPackageAndTask","targetId","parts","split","startsWith","packageName","getStartTargetId","START_TARGET_ID","detectCycles","visitMap","nodeId","cycle","searchForCycleDFS","hasCycle","graph","stack","node","traversing","current","pop","listOfCycle","filter","slice","indexOf","dependents","n","getPackageDependencies_1","getPackageDependencies","info","packages","withDevDependencies","deps","dependencies","devDependencies","withPeerDependencies","peerDependencies","keys","pkg","createDependencyMap_1","createDependencyMap","dep","Set","expandDepSpecs","_targetIdJs","dependencyMap","addDependency","from","to","findDependenciesByTask","targetList","needle","needleTask","needlePackageName","some","depPkg","depSpecs","dependencyTargetId","dependencyTargetIds","substring","getTransitiveGraphDependencies","dependencyIds","dependencyId","cachedTransitiveTaskDependencies","cachedResult","immediateDependencies","transitiveDepSet","immediateDependency","transitiveSubDependency","topologicalSort","nodesWithNoDependencies","sortedList","dependsOnMap","key","nodesWithNoDependenciesClone","currentId","forEach","childId","childNode","delete","size","prioritize","nodeCumulativePriorities","getNodesWithNoDependencies","topoSortedNodeIds","currentNodeId","currentNodePriority","childrenPriorities","childCumulativePriority","result","cumulativePriority","TargetGraphBuilder","_prioritizeJs","_detectCyclesJs","addTarget","dependency","dependent","build","cycleInfo","concat","subgraph","entriesTargetIds","subgraphBuilder","visited","shift","startId","cwd","label","hidden","getWeight","TargetFactory","_getWeightJs","createPackageTarget","config","dependsOn","cache","inputs","outputs","environmentGlob","createGlobalTarget","root","WorkspaceTargetGraphBuilder","_createDependencyMapJs","_expandDepSpecsJs","_path","_targetGraphBuilderJs","_targetFactoryJs","addTargetConfig","targetFactory","graphBuilder","packageInfos","tasks","scope","fullDependencies","subGraphEntries","dirname","packageJsonPath","_sortTargetsByPriorityJs","_workspaceTargetGraphBuilderJs","TargetRunnerPicker","_targetGraph","_url","NoOpRunner$1","NoOpRunner","importScript","pathToFileURL","runnerModule","import","base","basename","runnerName","extname","targetWorker","_workerThreadsPool","_targetRunnerPickerJs","runnerPicker","runners","workerData","runner","pick","run"],"mappings":"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"}